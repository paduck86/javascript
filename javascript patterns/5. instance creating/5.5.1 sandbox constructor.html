<script>
    /* 전역 생성자
        네임스페이스 패턴에서는 전역 객체가 하나다. 샌드박스 패턴의 유일한 전역은 생성자다.
        이것을 Sandbox()라고 하자. 이 생성자를 통해 객체들을 생성할 것이다.
        그리고 이 생성자에게 콜백 함수를 전달해 해당 코드를 샌드박스 내부 환경으로 격리시킬 것이다.
        샌드박스 사용법은 다음과 같다.

        new Sandbox(function (box) {
            // 여기에 코드가 들어간다...
        });

        box 객체는 네임스페이스 패턴에서의 MYAPP과 같은 것이다. 코드가 동작하는데 필요한 모든 라이브러리
        기능들이 여기에 들어간다.
        이 패턴에 두가지를 추가해보자.

        - 3장에서 나왔던 new를 강제하는 패턴을 활용하여 객체를 생성할 때 new를 쓰지 않아도 되게 만든다.
        - Sandbox() 생성자가 선택적인 인자를 하나 이상 받을 수 있게 한다.
          이 인자들은 객체를 생성하는 데 필요한 모듈의 이름을 지정한다.
          우리는 코드의 모듈화를 지향하고 있으므로 Sandbox()가 제공하는 기능 대부분이 실제로는
          모듈 안에 담겨지게 될 것이다.

        다음과 같이 new를 쓰지 않고도, 가상의 모듈 'ajax'와 'event'를 사용하는 객체를 만들 수 있다.

        Sandbox(['ajax','event'], function(box) {
            // console.log(box);
        });

        다음 예제는 앞선 예제와 비슷하지만 모듈 이름을 개별적인 인자로 전달한다.

        Sandbox('ajax', 'dom', function (box) {
            // console.log(box);
        });

        마지막으로 샌드박스 객체의 인스턴스를 여러개 만드는 예제를 살펴보자.
        심지어 한 인스턴스 내부에 다른 인스턴스를 중첩시킬 수도 있다.
        이 때도 두 인스턴스간의 간섭현상은 일어나지 않는다.

        Sandbox('dom', 'event', function (box) {
            //dom과 event를 가지고 작업하는 코드
            Sandbox('ajax', function (box) {
                // 샌드박스된 box 객체를 또 하나 만든다.

                // 이 box 객체는 바깥쪽 함수의 box 객체와는 다르다.

                // ajax를 사용하는 작업 완료
            });

            // 더 이상 ajax 모듈의 흔적은 찾아볼 수 없다.
        });

        이 예제들에서 볼 수 있듯이, 샌드박스 패턴을 사용하면 콜백 함수로 코드를 감싸기 때문에,
        전역 네임스페이스를 보호할 수 있다.
        필요하다면 함수가 곧 객체라는 사실을 활용하여 Sandbox() 생성자의 '스태틱' 프로퍼티에 데이터를 저장할 수도 있다.
        또 원하는 유형별로 모듈의 인스턴스를 여러개 만들 수도 있다.
        이 인스턴스들은 각각 독립적으로 동작하게 된다.
        그럼 이제 이 모든 기능을 지원하는 Sandbox() 생성자와 그 모듈을 구현하는 방법을 살펴보자.
     */
</script>